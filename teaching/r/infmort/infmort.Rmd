---
title: citytemps
output:
  md_document:
    includes:
      in_header: ../header.txt
---

In this walk-through, you'll learn fit a power law curve to data using linear least squares and the log transformation.  The log transform is often useful for data bounded below by 0, or data that span many orders of magnitude.

Data files:  
* [infmort.csv](infmort.csv): infant mortality and size of economy for 207 countries.

### Log transformations

First load the two libraries you'll need: mosaic and faraway.
```{r, message=FALSE}
library(mosaic)
library(faraway)
```
If you can an error like this:
```
Error in library(faraway) : there is no package called ‘faraway’
```
then you need to install the `faraway` package.

Next, read in the infant mortality data set.  The variables are infant deaths per 1000 live births and GDP per capita, in U.S. dollars.
```{r}
infmort = read.csv('infmort.csv', header=TRUE)
```
If you use the Import Dataset button in RStudio, you won't need this line.

We'll start by plotting the data:
```{r}
summary(infmort)
plot(mortality ~ gdp, data=infmort)
```
There's a noticeable bunching of the data at the left of the plot.  This happens because GDP is a highly skewed variables: many many small economies, and a small handful of large ones.  We can see this effect quite easily in a histogram.
```{r}
hist(infmort$gdp, breaks=20)
```
Note the long right tail.  This suggests that we should try using the logarithm of GDP, which will have the effect of unbunching the data.  Let's try plotting infant mortality versus log GDP, by specifying that we want the x variable to be displayed on a log scale.
```{r}
plot(mortality ~ log(gdp), data=infmort)
```

Notice that scale of the x axis changes: it's measured in units of log GDP now.  (In R, log means natural log... if you want the base-10 logarithm, use log10 instead.)

This plot looks better, but now we notice that the points are bunched toward the bottom of the plot.  This suggest we might also try taking the log of the y variable.
```{r}
plot(log(mortality) ~ log(gdp), data=infmort)
```

A straight line looks like it would fit very well here:
```{r}
lm1 = lm(log(mortality) ~ log(gdp), data= infmort)
coef(lm1)
```

We can add the line straight to the plot on the log-log scale:
```{r}
plot(log(mortality) ~ log(gdp), data=infmort)
abline(lm1)
```

### Displaying the model on the original scale

Suppose we wanted to show the model on the original scale.  We know that a linear model on the log-log scale corresponds to a power law on the original scale.  Let's exploit this to generate a plot of the fitted curve.  First let's remember what the data looks like on the original scale.
```{r}
plot(mortality ~ gdp, data= infmort)
```

Next, let's get the fitted values on the log-log scale, and transform them back to the original scale.  Because the exponential is the inverse of the log transform, we do this by exponentiating the fitted values:
```{r}
# Extract the coefficients and compute the fitted values "by hand"
mybeta = coef(lm1)
logmort.pred = mybeta[1] + mybeta[2]*log(infmort$gdp)
# Transform the fitted values to the original scale
mort.pred = exp(logmort.pred)
```

Now we can add the predicted points to the plot in a different color and point style:
```{r}
plot(mortality ~ gdp, data=infmort)
points(mort.pred ~ gdp, data=infmort, col='blue', pch=18)
```
Try typing in ?points if you want to see the options for pch.

We could also add the fitted curve directly to the scatter plot using the `curve` function, based on what we know about power laws and log transformations:
```{r}
plot(mortality ~ gdp, data= infmort)
curve(exp(mybeta[1]) * x^(mybeta[2]), add=TRUE, col='blue')
```
The `curve` function allows you to treat R as a graphing calculator.  It can plot functions or add those functions to existing scatter plots, as above.


